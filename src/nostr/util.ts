import type { HexKey, IContact, IProfileContent, Nprofile, Npub } from '@model/nostr'
import { secureStore, store } from '@store'
import { SECRET, STORE_KEYS } from '@store/consts'
import { cTo } from '@store/utils'
import { isStr, uniq } from '@util'
import { Event as NostrEvent, generatePrivateKey, getPublicKey, nip19 } from 'nostr-tools'

/**
 * Get a huge list of available relays
 */
export async function getRelays() {
	const resp = await fetch('https://api.nostr.watch/v1/relays')
	const relays = await resp.json<Promise<string[]>>()
	return relays
}

/**
 * Converts a NIP05 to an URL using name and domain identifier: `https://${domain}/.well-known/nostr.json?name=${name}`
 */
export function nip05toURL(identifier: string) {
	const [name, domain] = identifier.split('@')
	return `https://${domain}/.well-known/nostr.json?name=${name}`
}

/**
 * Converts a NIP-05 identifier to a website URL.
 *
 * @param identifier - The NIP-05 identifier to be converted.
 * @returns The website URL formed from the identifier's domain.
 */
export function nip05toWebsite(identifier: string) {
	const domain = identifier.split('@')[1]
	return `https://${domain}`
}

/**
 * JSON.parse the nostr user profile metadata
 */
export function parseProfileContent(event: NostrEvent) {
	return cTo<IProfileContent>(event.content)
}

/**
 * Filters out the hashtag follows
 */
export function filterFollows(tags: string[][]) {
	return uniq(tags
		.filter(t => t?.[0] === 'p' && isHex(t?.[1]))
		.map(t => t[1]))
		.sort((a, b) => a.localeCompare(b))
}

/**
 * JSON.parse the nostr relays from user
 */
export function parseUserRelays(relays: string) {
	return Object.keys(cTo(relays))
}

/**
 * Truncates the npub of a user
 */
export function truncateNpub(npub: string) {
	return npub.slice(0, 8) + ':' + npub.slice(-8)
}

/**
 * Truncates a string while preserving emojis.
 *
 * @param about - The input string to be truncated.
 * @param maxLength - The maximum length of the truncated string.
 * @returns The truncated string.
 */
export function truncateStr(str: string, maxLength = 20) {
	if (str.length <= maxLength) { return str }
	const truncated = [...str].slice(0, maxLength).join('')
	return `${truncated}...`
}

/**
 * Retrieves the username from a profile contact object, prioritizing different properties.
 *
 * @param contact - The profile contact object to extract the username from.
 * @returns The extracted username. Returns an empty string if no username is found.
 */
export function getNostrUsername(contact?: IContact) {
	return contact?.displayName || contact?.display_name || contact?.username || contact?.name || ''
}

export function isHex(s: unknown): s is string {
	return isStr(s) && s.length === 64 && /[0-9a-fA-F]{64}/.test(s)
}

export function isNpub(s: unknown): s is Npub {
	return isStr(s) && s.length === 63 && /npub1[023456789acdefghjklmnpqrstuvwxyz]{58}/.test(s)
}

export function isNProfile(s: unknown): s is Nprofile {
	return isStr(s) && s.length === 70 && /nprofile1[023456789acdefghjklmnpqrstuvwxyz]{58}/.test(s)
}

export function isNpubQR(str: string) {
	if (!str || !isStr(str)) { return }
	str = str.trim()
	if (isNpub(str)) { return str }
	try {
		const u = new URL(str)
		// l(u.protocol, u.host, u.toString())
		const clean = u.hostname || u.pathname
		if (!isNpub(clean)) { return }
		return clean
	} catch (_) {/* ignored */ }
}

export async function handleNewNpub(hex: HexKey, initSecret = false) {
	const pub = {
		encoded: nip19.npubEncode(hex),
		hex
	}
	await Promise.all([
		store.set(STORE_KEYS.npub, pub.encoded), 	// save nostr encoded pubKey
		store.set(STORE_KEYS.npubHex, pub.hex),		// save nostr hex pubKey
	])
	if (initSecret) {
		const sk = generatePrivateKey() 			// `sk` is a hex string
		const pk = getPublicKey(sk)					// `pk` is a hex string
		await Promise.all([
			store.set(STORE_KEYS.nutpub, pk),		// save enuts hex pubKey
			secureStore.set(SECRET, sk)				// save nostr secret generated by enuts for nostr DM interactions
		])
	}
}

export function npubEncode(hex: HexKey) {
	if (!isHex(hex)) { return '' }
	let npub = ''
	try {
		npub = nip19.npubEncode(hex)
	} catch (e) {
		return ''
	}
	return npub
}

export function normalizeURL(url: string): string {
	const p = new URL(url)
	p.pathname = p.pathname.replace(/\/+/g, '/')
	if (p.pathname.endsWith('/')) { p.pathname = p.pathname.slice(0, -1) }
	if ((p.port === '80' && p.protocol === 'ws:') || (p.port === '443' && p.protocol === 'wss:')) { p.port = '' }
	p.searchParams.sort()
	p.hash = ''
	return p.toString()
}

export function shuffle<T>(a: T[]) {
	for (let i = a.length - 1; i > 0; i--) {
		const j = Math.floor(Math.random() * (i + 1));
		[a[i], a[j]] = [a[j], a[i]]
	}
	return a
}

export function hasRelayValidPrefix(str: string) {
	const validPrefixes = ['http', 'https', 'ws', 'wss']
	return validPrefixes.some(prefix => str.startsWith(prefix))
}